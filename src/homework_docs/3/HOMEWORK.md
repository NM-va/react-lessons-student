# Домашнее задание: Универсальный компонент ввода в React

## Введение

В этом задании вам предстоит создать гибкий и переиспользуемый компонент ввода (`UniversalInput`), который сможет функционировать как в контролируемом, так и в неконтролируемом режиме в зависимости от переданных пропсов. Этот компонент должен демонстрировать понимание разницы между этими двумя подходами к управлению формами в React.

## Цель задания

Разработать универсальный компонент ввода, который:

- Будет корректно работать как контролируемый компонент, если передан проп `value` и `onChange`
- Будет корректно работать как неконтролируемый компонент, если не переданы пропсы `value` и `onChange`
- Обеспечит плавный интерфейс для использования в обоих режимах
- Будет правильно обрабатывать ссылки (refs)
- Поддержит валидацию для контролируемого режима

## Требования

1. **Компонент UniversalInput**:
   - Должен определять режим работы по наличию пропсов `value` и `onChange`
   - Должен принимать все стандартные HTML-атрибуты input (placeholder, type, disabled и т.д.)
   - Должен корректно обрабатывать ref для доступа к DOM-элементу
   - Не должен вызывать предупреждения React о переходе между контролируемым и неконтролируемым режимами

2. **Демо-компонент для демонстрации работы**:
   - Должен демонстрировать работу в контролируемом режиме с валидацией
   - Должен демонстрировать работу в неконтролируемом режиме
   - Должен включать элементы управления для демонстрации функциональности
   - Должен наглядно показывать разницу между подходами

3. **Дополнительная функциональность**:
   - Поддержка валидации для контролируемого режима
   - Возможность программного управления фокусом через ref
   - Обработка событий blur, focus и других, если указаны

## Шаблоны для начала работы

### UniversalInput.js

```jsx
import React, { useRef, useEffect, forwardRef } from 'react';

// Универсальный компонент ввода, работающий как контролируемый или неконтролируемый
const UniversalInput = forwardRef(({
  value,
  onChange,
  defaultValue = '',
  // Добавьте другие необходимые пропсы
  ...props
}, ref) => {
  const inputRef = useRef(null);
  
  // Объединяем внешний ref с внутренним
  useEffect(() => {
    if (ref) {
      if (typeof ref === 'function') {
        ref(inputRef.current);
      } else {
        ref.current = inputRef.current;
      }
    }
  }, [ref]);
  
  // Определяем, является ли компонент контролируемым
  const isControlled = value !== undefined && onChange !== undefined;
  
  // TODO: Реализуйте логику компонента
  
  return (
    <input
      ref={inputRef}
      // TODO: Добавьте правильные пропсы в зависимости от режима
      {...props}
    />
  );
});

export default UniversalInput;
```

### DemoComponent.js

```jsx
import React, { useState, useRef } from 'react';
import UniversalInput from './UniversalInput';

function DemoComponent() {
  // Состояние для контролируемого режима
  const [controlledValue, setControlledValue] = useState('');
  
  // Ref для доступа к неконтролируемому инпуту
  const uncontrolledInputRef = useRef(null);
  
  // Ref для доступа к универсальному инпуту в неконтролируемом режиме
  const universalUncontrolledRef = useRef(null);
  
  // TODO: Реализуйте демо-компонент, показывающий работу UniversalInput
  // в обоих режимах: контролируемом и неконтролируемом
  
  return (
    <div className="demo-container">
      <h2>Демонстрация UniversalInput</h2>
      
      {/* Контролируемый режим */}
      <div className="input-section">
        <h3>Контролируемый режим</h3>
        {/* TODO: Добавьте UniversalInput в контролируемом режиме */}
      </div>
      
      {/* Неконтролируемый режим */}
      <div className="input-section">
        <h3>Неконтролируемый режим</h3>
        {/* TODO: Добавьте UniversalInput в неконтролируемом режиме */}
      </div>
      
      {/* Элементы управления */}
      <div className="controls">
        {/* TODO: Добавьте кнопки для демонстрации функциональности */}
      </div>
    </div>
  );
}

export default DemoComponent;
```

## Рекомендации по реализации

1. **Для корректной работы с refs**:
   - Используйте `forwardRef` для правильной передачи ссылок
   - Обработайте случаи когда ref может быть функцией или объектом

2. **Для определения режима работы**:
   - Проверяйте наличие пропсов `value` и `onChange`
   - В контролируемом режиме используйте пропсы `value` и `onChange`
   - В неконтролируемом режиме используйте `defaultValue` и внутренний `ref`

3. **Для валидации в контролируемом режиме**:
   - Создайте отдельную функцию валидации
   - Применяйте валидацию при каждом изменении в контролируемом режиме
   - Отображайте сообщения об ошибках рядом с полем ввода

4. **Для программного управления фокусом**:
   - Создайте методы для установки/снятия фокуса через ref
   - Добавьте кнопки в демо для демонстрации

5. **Избегайте предупреждений React**:
   - Не смешивайте контролируемые и неконтролируемые атрибуты для одного input
   - Используйте условную логику для определения нужных пропсов

## Порядок выполнения

1. Создайте базовую структуру `UniversalInput`, используя `forwardRef`
2. Реализуйте логику определения режима работы компонента
3. Добавьте корректную обработку пропсов для каждого режима
4. Реализуйте демо-компонент для демонстрации работы в обоих режимах
5. Добавьте валидацию для контролируемого режима
6. Реализуйте программное управление фокусом через ref
7. Протестируйте компонент в разных сценариях использования
8. Добавьте комментарии, объясняющие логику работы компонента

## Пример использования

```jsx
// Использование в контролируемом режиме
<UniversalInput
  value={inputValue}
  onChange={(e) => setInputValue(e.target.value)}
  placeholder="Контролируемый ввод"
/>

// Использование в неконтролируемом режиме
<UniversalInput
  defaultValue="Начальное значение"
  ref={inputRef}
  placeholder="Неконтролируемый ввод"
/>
```

## Критерии оценки

1. **Функциональность (40%)**:
   - Компонент корректно работает в обоих режимах
   - Корректно обрабатываются пропсы и refs
   - Реализована валидация в контролируемом режиме
   - Работает программное управление фокусом

2. **Качество кода (30%)**:
   - Чистый, хорошо организованный код
   - Отсутствие дублирования и избыточности
   - Эффективное использование React-паттернов
   - Соблюдение принципов функционального программирования

3. **Документация и комментарии (20%)**:
   - Наличие понятных комментариев
   - Документированы все пропсы и их назначение
   - Объяснены ключевые решения и подходы

4. **Дополнительные улучшения (10%)**:
   - Типизация с использованием PropTypes или TypeScript
   - Дополнительная функциональность сверх требований
   - Тесты компонента
   - UI/UX улучшения демо-компонента

## Сдача задания

Задание должно быть выполнено в виде репозитория с двумя файлами:

1. `UniversalInput.js` - готовый компонент
2. `DemoComponent.js` - демо-компонент, показывающий работу `UniversalInput`

При сдаче необходимо продемонстрировать работу компонента в обоих режимах и объяснить ключевые аспекты реализации.

---

## Подсказки и советы

- Помните, что ключевое различие между контролируемыми и неконтролируемыми компонентами - это "источник истины". В контролируемых компонентах это состояние React, в неконтролируемых - DOM.
- Обратите внимание на правильную обработку событий в обоих режимах.
- Для валидации в контролируемом режиме можно использовать дополнительное состояние для хранения ошибок.
- Используйте консольные логи для отладки и понимания жизненного цикла компонента.
- React предупреждает об изменении компонента из неконтролируемого в контролируемый и наоборот - убедитесь, что ваш компонент не меняет режим работы во время использования.

Удачи в выполнении задания!
